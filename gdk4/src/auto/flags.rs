// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files.git)
// DO NOT EDIT

use bitflags::bitflags;
use glib::translate::*;
use glib::value::FromValue;
use glib::value::ToValue;
use glib::StaticType;
use glib::Type;
use std::fmt;

bitflags! {
    #[doc(alias = "GdkAnchorHints")]
    pub struct AnchorHints: u32 {
        #[doc(alias = "GDK_ANCHOR_FLIP_X")]
        const FLIP_X = 1;
        #[doc(alias = "GDK_ANCHOR_FLIP_Y")]
        const FLIP_Y = 2;
        #[doc(alias = "GDK_ANCHOR_SLIDE_X")]
        const SLIDE_X = 4;
        #[doc(alias = "GDK_ANCHOR_SLIDE_Y")]
        const SLIDE_Y = 8;
        #[doc(alias = "GDK_ANCHOR_RESIZE_X")]
        const RESIZE_X = 16;
        #[doc(alias = "GDK_ANCHOR_RESIZE_Y")]
        const RESIZE_Y = 32;
        #[doc(alias = "GDK_ANCHOR_FLIP")]
        const FLIP = 3;
        #[doc(alias = "GDK_ANCHOR_SLIDE")]
        const SLIDE = 12;
        #[doc(alias = "GDK_ANCHOR_RESIZE")]
        const RESIZE = 48;
    }
}

impl fmt::Display for AnchorHints {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for AnchorHints {
    type GlibType = ffi::GdkAnchorHints;

    fn into_glib(self) -> ffi::GdkAnchorHints {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkAnchorHints> for AnchorHints {
    unsafe fn from_glib(value: ffi::GdkAnchorHints) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for AnchorHints {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_anchor_hints_get_type()) }
    }
}

impl glib::value::ValueType for AnchorHints {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AnchorHints {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for AnchorHints {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkAxisFlags")]
    pub struct AxisFlags: u32 {
        #[doc(alias = "GDK_AXIS_FLAG_X")]
        const X = 2;
        #[doc(alias = "GDK_AXIS_FLAG_Y")]
        const Y = 4;
        #[doc(alias = "GDK_AXIS_FLAG_DELTA_X")]
        const DELTA_X = 8;
        #[doc(alias = "GDK_AXIS_FLAG_DELTA_Y")]
        const DELTA_Y = 16;
        #[doc(alias = "GDK_AXIS_FLAG_PRESSURE")]
        const PRESSURE = 32;
        #[doc(alias = "GDK_AXIS_FLAG_XTILT")]
        const XTILT = 64;
        #[doc(alias = "GDK_AXIS_FLAG_YTILT")]
        const YTILT = 128;
        #[doc(alias = "GDK_AXIS_FLAG_WHEEL")]
        const WHEEL = 256;
        #[doc(alias = "GDK_AXIS_FLAG_DISTANCE")]
        const DISTANCE = 512;
        #[doc(alias = "GDK_AXIS_FLAG_ROTATION")]
        const ROTATION = 1024;
        #[doc(alias = "GDK_AXIS_FLAG_SLIDER")]
        const SLIDER = 2048;
    }
}

impl fmt::Display for AxisFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for AxisFlags {
    type GlibType = ffi::GdkAxisFlags;

    fn into_glib(self) -> ffi::GdkAxisFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkAxisFlags> for AxisFlags {
    unsafe fn from_glib(value: ffi::GdkAxisFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for AxisFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_axis_flags_get_type()) }
    }
}

impl glib::value::ValueType for AxisFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for AxisFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for AxisFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkDragAction")]
    pub struct DragAction: u32 {
        #[doc(alias = "GDK_ACTION_COPY")]
        const COPY = 1;
        #[doc(alias = "GDK_ACTION_MOVE")]
        const MOVE = 2;
        #[doc(alias = "GDK_ACTION_LINK")]
        const LINK = 4;
        #[doc(alias = "GDK_ACTION_ASK")]
        const ASK = 8;
    }
}

impl DragAction {
    #[doc(alias = "gdk_drag_action_is_unique")]
    pub fn is_unique(self) -> bool {
        assert_initialized_main_thread!();
        unsafe { from_glib(ffi::gdk_drag_action_is_unique(self.into_glib())) }
    }
}

impl fmt::Display for DragAction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DragAction {
    type GlibType = ffi::GdkDragAction;

    fn into_glib(self) -> ffi::GdkDragAction {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkDragAction> for DragAction {
    unsafe fn from_glib(value: ffi::GdkDragAction) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for DragAction {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_drag_action_get_type()) }
    }
}

impl glib::value::ValueType for DragAction {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for DragAction {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for DragAction {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkFrameClockPhase")]
    pub struct FrameClockPhase: u32 {
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_NONE")]
        const NONE = 0;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_FLUSH_EVENTS")]
        const FLUSH_EVENTS = 1;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_BEFORE_PAINT")]
        const BEFORE_PAINT = 2;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_UPDATE")]
        const UPDATE = 4;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_LAYOUT")]
        const LAYOUT = 8;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_PAINT")]
        const PAINT = 16;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_RESUME_EVENTS")]
        const RESUME_EVENTS = 32;
        #[doc(alias = "GDK_FRAME_CLOCK_PHASE_AFTER_PAINT")]
        const AFTER_PAINT = 64;
    }
}

impl fmt::Display for FrameClockPhase {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for FrameClockPhase {
    type GlibType = ffi::GdkFrameClockPhase;

    fn into_glib(self) -> ffi::GdkFrameClockPhase {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkFrameClockPhase> for FrameClockPhase {
    unsafe fn from_glib(value: ffi::GdkFrameClockPhase) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for FrameClockPhase {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_frame_clock_phase_get_type()) }
    }
}

impl glib::value::ValueType for FrameClockPhase {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for FrameClockPhase {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for FrameClockPhase {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkModifierType")]
    pub struct ModifierType: u32 {
        #[doc(alias = "GDK_SHIFT_MASK")]
        const SHIFT_MASK = 1;
        #[doc(alias = "GDK_LOCK_MASK")]
        const LOCK_MASK = 2;
        #[doc(alias = "GDK_CONTROL_MASK")]
        const CONTROL_MASK = 4;
        #[doc(alias = "GDK_ALT_MASK")]
        const ALT_MASK = 8;
        #[doc(alias = "GDK_BUTTON1_MASK")]
        const BUTTON1_MASK = 256;
        #[doc(alias = "GDK_BUTTON2_MASK")]
        const BUTTON2_MASK = 512;
        #[doc(alias = "GDK_BUTTON3_MASK")]
        const BUTTON3_MASK = 1024;
        #[doc(alias = "GDK_BUTTON4_MASK")]
        const BUTTON4_MASK = 2048;
        #[doc(alias = "GDK_BUTTON5_MASK")]
        const BUTTON5_MASK = 4096;
        #[doc(alias = "GDK_SUPER_MASK")]
        const SUPER_MASK = 67108864;
        #[doc(alias = "GDK_HYPER_MASK")]
        const HYPER_MASK = 134217728;
        #[doc(alias = "GDK_META_MASK")]
        const META_MASK = 268435456;
    }
}

impl fmt::Display for ModifierType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ModifierType {
    type GlibType = ffi::GdkModifierType;

    fn into_glib(self) -> ffi::GdkModifierType {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkModifierType> for ModifierType {
    unsafe fn from_glib(value: ffi::GdkModifierType) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ModifierType {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_modifier_type_get_type()) }
    }
}

impl glib::value::ValueType for ModifierType {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ModifierType {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ModifierType {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkPaintableFlags")]
    pub struct PaintableFlags: u32 {
        #[doc(alias = "GDK_PAINTABLE_STATIC_SIZE")]
        const SIZE = 1;
        #[doc(alias = "GDK_PAINTABLE_STATIC_CONTENTS")]
        const CONTENTS = 2;
    }
}

impl fmt::Display for PaintableFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for PaintableFlags {
    type GlibType = ffi::GdkPaintableFlags;

    fn into_glib(self) -> ffi::GdkPaintableFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkPaintableFlags> for PaintableFlags {
    unsafe fn from_glib(value: ffi::GdkPaintableFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for PaintableFlags {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_paintable_flags_get_type()) }
    }
}

impl glib::value::ValueType for PaintableFlags {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for PaintableFlags {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for PaintableFlags {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkSeatCapabilities")]
    pub struct SeatCapabilities: u32 {
        #[doc(alias = "GDK_SEAT_CAPABILITY_NONE")]
        const NONE = 0;
        #[doc(alias = "GDK_SEAT_CAPABILITY_POINTER")]
        const POINTER = 1;
        #[doc(alias = "GDK_SEAT_CAPABILITY_TOUCH")]
        const TOUCH = 2;
        #[doc(alias = "GDK_SEAT_CAPABILITY_TABLET_STYLUS")]
        const TABLET_STYLUS = 4;
        #[doc(alias = "GDK_SEAT_CAPABILITY_KEYBOARD")]
        const KEYBOARD = 8;
        #[doc(alias = "GDK_SEAT_CAPABILITY_TABLET_PAD")]
        const TABLET_PAD = 16;
        #[doc(alias = "GDK_SEAT_CAPABILITY_ALL_POINTING")]
        const ALL_POINTING = 7;
        #[doc(alias = "GDK_SEAT_CAPABILITY_ALL")]
        const ALL = 15;
    }
}

impl fmt::Display for SeatCapabilities {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for SeatCapabilities {
    type GlibType = ffi::GdkSeatCapabilities;

    fn into_glib(self) -> ffi::GdkSeatCapabilities {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkSeatCapabilities> for SeatCapabilities {
    unsafe fn from_glib(value: ffi::GdkSeatCapabilities) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for SeatCapabilities {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_seat_capabilities_get_type()) }
    }
}

impl glib::value::ValueType for SeatCapabilities {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for SeatCapabilities {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for SeatCapabilities {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}

bitflags! {
    #[doc(alias = "GdkToplevelState")]
    pub struct ToplevelState: u32 {
        #[doc(alias = "GDK_TOPLEVEL_STATE_MINIMIZED")]
        const MINIMIZED = 1;
        #[doc(alias = "GDK_TOPLEVEL_STATE_MAXIMIZED")]
        const MAXIMIZED = 2;
        #[doc(alias = "GDK_TOPLEVEL_STATE_STICKY")]
        const STICKY = 4;
        #[doc(alias = "GDK_TOPLEVEL_STATE_FULLSCREEN")]
        const FULLSCREEN = 8;
        #[doc(alias = "GDK_TOPLEVEL_STATE_ABOVE")]
        const ABOVE = 16;
        #[doc(alias = "GDK_TOPLEVEL_STATE_BELOW")]
        const BELOW = 32;
        #[doc(alias = "GDK_TOPLEVEL_STATE_FOCUSED")]
        const FOCUSED = 64;
        #[doc(alias = "GDK_TOPLEVEL_STATE_TILED")]
        const TILED = 128;
        #[doc(alias = "GDK_TOPLEVEL_STATE_TOP_TILED")]
        const TOP_TILED = 256;
        #[doc(alias = "GDK_TOPLEVEL_STATE_TOP_RESIZABLE")]
        const TOP_RESIZABLE = 512;
        #[doc(alias = "GDK_TOPLEVEL_STATE_RIGHT_TILED")]
        const RIGHT_TILED = 1024;
        #[doc(alias = "GDK_TOPLEVEL_STATE_RIGHT_RESIZABLE")]
        const RIGHT_RESIZABLE = 2048;
        #[doc(alias = "GDK_TOPLEVEL_STATE_BOTTOM_TILED")]
        const BOTTOM_TILED = 4096;
        #[doc(alias = "GDK_TOPLEVEL_STATE_BOTTOM_RESIZABLE")]
        const BOTTOM_RESIZABLE = 8192;
        #[doc(alias = "GDK_TOPLEVEL_STATE_LEFT_TILED")]
        const LEFT_TILED = 16384;
        #[doc(alias = "GDK_TOPLEVEL_STATE_LEFT_RESIZABLE")]
        const LEFT_RESIZABLE = 32768;
    }
}

impl fmt::Display for ToplevelState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for ToplevelState {
    type GlibType = ffi::GdkToplevelState;

    fn into_glib(self) -> ffi::GdkToplevelState {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GdkToplevelState> for ToplevelState {
    unsafe fn from_glib(value: ffi::GdkToplevelState) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

impl StaticType for ToplevelState {
    fn static_type() -> Type {
        unsafe { from_glib(ffi::gdk_toplevel_state_get_type()) }
    }
}

impl glib::value::ValueType for ToplevelState {
    type Type = Self;
}

unsafe impl<'a> FromValue<'a> for ToplevelState {
    type Checker = glib::value::GenericValueTypeChecker<Self>;

    unsafe fn from_value(value: &'a glib::Value) -> Self {
        skip_assert_initialized!();
        from_glib(glib::gobject_ffi::g_value_get_flags(value.to_glib_none().0))
    }
}

impl ToValue for ToplevelState {
    fn to_value(&self) -> glib::Value {
        let mut value = glib::Value::for_value_type::<Self>();
        unsafe {
            glib::gobject_ffi::g_value_set_flags(value.to_glib_none_mut().0, self.into_glib());
        }
        value
    }

    fn value_type(&self) -> glib::Type {
        Self::static_type()
    }
}
